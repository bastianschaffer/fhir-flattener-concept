scenario:
- two backbone elements with multiple different nested children
- elementId to be flattened: Condition.stage 

resulting table:
Condition/cond-1,summary-system-A,summary-code-1,type-system-B,type-code-2-1
Condition/cond-1,summary-system-A,summary-code-1,type-system-C,type-code-2-2
Condition/cond-1,summary-system-A,summary-code-1,type-system-F,type-code-4-1
Condition/cond-1,summary-system-D,summary-code-3-1,type-system-B,type-code-2-1
Condition/cond-1,summary-system-D,summary-code-3-1,type-system-C,type-code-2-2
Condition/cond-1,summary-system-D,summary-code-3-1,type-system-F,type-code-4-1
Condition/cond-1,summary-system-E,summary-code-3-2,type-system-B,type-code-2-1
Condition/cond-1,summary-system-E,summary-code-3-2,type-system-C,type-code-2-2
Condition/cond-1,summary-system-E,summary-code-3-2,type-system-F,type-code-4-1

simplified:
resource:
{
stage: [
   {
    summary: [A],
    type: [B,C]
   },
   {
    summary: [D,E],
    type: [F]
   } 
]
}
table:
1,A,B
1,A,C
1,A,F
1,D,B
1,D,C
1,D,F
1,E,B
1,E,C
1,E,F

-> 9 rows for a single (rather simple) resource

Considerations on why it can't be done better:
- cardinalities of "*" mean that the amount of entries at that list is not known without knowing the resource (i.e. at viewDefinition generation time)
- so in the viewDefinition it must be defined at "generation time" to handle such cases later at "flattening time 
- this is done with "forEach" (creates one row for each found element)
- "forEach" can only be done at one element at a time
- so one could make a "forEach" at "Condition.stage" to generate a row for each stage
- but if "stage.summary.coding" also has cardinality "*", there would have to be another nested "forEach" that kind of handles only the elements of the parent "stage"
- but nested "forEach" is not possible in a ViewDefinition
- insead, the top level "forEach" must act on "Condition.stage.summary.coding" instead of "Condition.stage"
- it is not possible to do it differently because it MUST be handled to encounter multilpe codings at "Condition.stage.summary.coding"
- with this we arrive at the ViewDefinition that can be seen here in backbone-parent/viewDefinition.json

- maybe the "repeat" field of a ViewDefinition might help? 
- i tried to test how the "repeat" field works but the flattener seemed no not support the "repeat" field so i couldn't test this further

==> Solution: the "select" backbone element field does in fact allow for further nested "select" fields with which it might works
==> BUT: pathling seems to not execute nested selects correctly

TODO:
- specify rules to generate that lookup from profiles